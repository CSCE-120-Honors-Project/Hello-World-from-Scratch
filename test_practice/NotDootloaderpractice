
//.section .text
//.global _start

// start.S - First stage bootloader entry point
// ARM Cortex-A53 (ARMv8-A AArch64)

//.section .text.boot
//.global _start

//Linker script notes
//__text_boot_start -  This marks where the bootloader code begins.
// __text_boot_end = .; // this point in memory is the end of 
 //having both tells me mah code to determine the bootloader's size and address range



// mah code will start with this
// Declare the symbols (they're not variables, just addresses)
extern char __text_boot_start;
extern char __text_boot_end;

// Get their addresses
char *boot_code_start = &__text_boot_start;
char *boot_code_end = &__text_boot_end;

// Calculate bootloader size
size_t boot_size = (size_t)boot_code_end - (size_t)boot_code_start;


_start:
    // Save DTB address (passed in x0 by QEMU)
    mov     x20, x0
    
    // Check current exception level
    mrs     x0, CurrentEL // we should be in EL3
    and     x0, x0, #0xC        // Extract EL bits
    cmp     x0, #0x4            // Are we in EL1?
    b.eq    el1_entry
    
    // If EL2 or EL3, drop to EL1
    // For simplicity, assume QEMU starts us at EL1
    // (Add EL transition code here if needed)

el1_entry:
    // Disable interrupts
    msr     DAIFSet, #0xF

    // Set up stack pointer
    ldr     x1, =stack_top
    mov     sp, x1

    // Zero out BSS section
    ldr     x1, =__bss_start
    ldr     x2, =__bss_end
    
bss_clear_loop:
    cmp     x1, x2
    b.ge    bss_clear_done
    str     xzr, [x1], #8       // Write zero, increment by 8
    b       bss_clear_loop

bss_clear_done:
    // Copy .data section (if load address != execution address)
    // For simplicity in QEMU, skip this if not needed
    ldr     x1, =__data_start
    ldr     x2, =__data_end
    ldr     x3, =__data_load
    
data_copy_loop:
    cmp     x1, x2
    b.ge    data_copy_done
    ldr     x4, [x3], #8
    str     x4, [x1], #8
    b       data_copy_loop

data_copy_done:
    // Restore DTB address and call C++ main
    mov     x0, x20
    bl      boot_main

    // If boot_main returns, hang
hang:
    wfe
    b       hang

// Exception vector table (minimal)
.balign 0x800
.global vector_table_el1
vector_table_el1:
    // Current EL with SP0
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    
    // Current EL with SPx
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    
    // Lower EL using AArch64
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    
    // Lower EL using AArch32
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang
    .balign 0x80
    b       hang



//File 2: boot.cpp (C++ Main Bootloader Logic) cpp


// boot.cpp - Second stage bootloader main logic

#include <cstdint>
#include "uart.h"

// Simple string functions
extern "C" {

void* memset(void* s, int c, size_t n) {
    uint8_t* p = (uint8_t*)s;
    while (n--) *p++ = (uint8_t)c;
    return s;
}

size_t strlen(const char* s) {
    size_t len = 0;
    while (s[len]) len++;
    return len;
}

// Main bootloader entry point
void boot_main(void* dtb_address) {
    // Initialize UART for debug output
    uart_init();
    
    uart_puts("\n\r");
    uart_puts("=================================\n\r");
    uart_puts("ARM Cortex-A53 Bootloader v1.0\n\r");
    uart_puts("=================================\n\r");
    
    // Print DTB address
    uart_puts("Device Tree Blob at: 0x");
    uart_print_hex((uint64_t)dtb_address);
    uart_puts("\n\r");
    
    // Parse DTB header (simplified)
    uint32_t* dtb = (uint32_t*)dtb_address;
    uint32_t magic = __builtin_bswap32(dtb);  // DTB is big-endian
    
    uart_puts("DTB Magic: 0x");
    uart_print_hex(magic);
    uart_puts("\n\r");
    
    if (magic == 0xd00dfeed) {
        uart_puts("Valid Device Tree found!\n\r");
    } else {
        uart_puts("Invalid Device Tree magic!\n\r");
    }
    
    // Here you would:
    // 1. Parse DTB for memory info
    // 2. Locate kernel image
    // 3. Set up boot parameters
    // 4. Jump to kernel
    
    uart_puts("\n\rBootloader complete.\n\r");
    uart_puts("(No kernel loaded - halting)\n\r");
    
    // Infinite loop (replace with kernel jump)
    while (1) {
        asm volatile("wfe");
    }
}

} // extern "C"
File 3: uart.h (UART Header)
cpp
// uart.h - PL011 UART driver header

#ifndef UART_H
#define UART_H

#include <cstdint>

// PL011 UART base address for QEMU virt
#define UART0_BASE 0x09000000

void uart_init();
void uart_putc(char c);
void uart_puts(const char* str);
void uart_print_hex(uint64_t value);

#endif // UART_H
File 4: uart.cpp (UART Implementation)
cpp
// uart.cpp - PL011 UART driver implementation

#include "uart.h"

// PL011 UART Register offsets
#define UART_DR     0x00  // Data Register
#define UART_FR     0x18  // Flag Register
#define UART_IBRD   0x24  // Integer Baud Rate Divisor
#define UART_FBRD   0x28  // Fractional Baud Rate Divisor
#define UART_LCRH   0x2C  // Line Control Register
#define UART_CR     0x30  // Control Register
#define UART_IMSC   0x38  // Interrupt Mask Set/Clear

// Flag Register bits
#define FR_TXFF     (1 << 5)  // Transmit FIFO full
#define FR_RXFE     (1 << 4)  // Receive FIFO empty

// Control Register bits
#define CR_UARTEN   (1 << 0)  // UART Enable
#define CR_TXE      (1 << 8)  // Transmit Enable
#define CR_RXE      (1 << 9)  // Receive Enable

// Line Control Register bits
#define LCRH_FEN    (1 << 4)  // Enable FIFOs
#define LCRH_WLEN8  (3 << 5)  // 8-bit word length

static inline void mmio_write(uint64_t addr, uint32_t value) {
    *(volatile uint32_t*)addr = value;
}

static inline uint32_t mmio_read(uint64_t addr) {
    return *(volatile uint32_t*)addr;
}

void uart_init() {
    uint64_t base = UART0_BASE;
    
    // Disable UART
    mmio_write(base + UART_CR, 0);
    
    // Wait for current transmission to complete
    while (mmio_read(base + UART_FR) & FR_TXFF);
    
    // Flush transmit FIFO
    mmio_write(base + UART_LCRH, mmio_read(base + UART_LCRH) & ~LCRH_FEN);
    
    // Set baud rate to 115200
    // UART clock is 24MHz in QEMU virt
    // Divisor = UART_CLK / (16 * Baud_rate)
    // Divisor = 24000000 / (16 * 115200) = 13.02
    // Integer part = 13, Fractional part = 0.02 * 64 = 1
    mmio_write(base + UART_IBRD, 13);
    mmio_write(base + UART_FBRD, 1);
    
    // Enable FIFOs and set 8-bit word length
    mmio_write(base + UART_LCRH, LCRH_FEN | LCRH_WLEN8);
    
    // Disable all interrupts
    mmio_write(base + UART_IMSC, 0);
    
    // Enable UART, TX, and RX
    mmio_write(base + UART_CR, CR_UARTEN | CR_TXE | CR_RXE);
}

void uart_putc(char c) {
    uint64_t base = UART0_BASE;
    
    // Wait until transmit FIFO has space
    while (mmio_read(base + UART_FR) & FR_TXFF);
    
    // Write character
    mmio_write(base + UART_DR, (uint32_t)c);
}

void uart_puts(const char* str) {
    while (*str) {
        if (*str == '\n') {
            uart_putc('\r');  // Add carriage return before newline
        }
        uart_putc(*str++);
    }
}

void uart_print_hex(uint64_t value) {
    const char hex_chars[] = "0123456789ABCDEF";
    char buffer;
    buffer = '\0';
    
    for (int i = 15; i >= 0; i--) {
        buffer[i] = hex_chars[value & 0xF];
        value >>= 4;
    }
    
    uart_puts(buffer);
}
File 5: linker.ld (Linker Script)
text
/* linker.ld - Linker script for ARM Cortex-A53 bootloader */

ENTRY(_start)

SECTIONS
{
    /* QEMU virt loads kernel at 0x40000000 */
    . = 0x40000000;
    
    .text : {
        KEEP(*(.text.boot))  /* Entry point first */
        *(.text*)
        *(.rodata*)
    }
    
    .data : {
        __data_start = .;
        *(.data*)
        __data_end = .;
    }
    
    .bss : {
        __bss_start = .;
        *(.bss*)
        *(COMMON)
        __bss_end = .;
    }
    
    /* Stack grows downward from here */
    . = ALIGN(16);
    . += 0x4000;  /* 16KB stack */
    stack_top = .;
    
    /* Data load address (same as execution for QEMU) */
    __data_load = LOADADDR(.data);
    
    /DISCARD/ : {
        *(.comment)
        *(.eh_frame*)
    }
}
File 6: Makefile
makefile
# Makefile for ARM Cortex-A53 bootloader

# Toolchain
PREFIX = aarch64-none-elf-
CC = $(PREFIX)gcc
CXX = $(PREFIX)g++
AS = $(PREFIX)as
LD = $(PREFIX)ld
OBJCOPY = $(PREFIX)objcopy
OBJDUMP = $(PREFIX)objdump

# Flags
CFLAGS = -Wall -O2 -ffreestanding -nostdlib -nostartfiles
CXXFLAGS = $(CFLAGS) -fno-exceptions -fno-rtti
ASFLAGS = 
LDFLAGS = -T linker.ld

# Source files
ASM_SRC = start.S
CPP_SRC = boot.cpp uart.cpp
OBJS = start.o boot.o uart.o

# Output
TARGET = bootloader
ELF = $(TARGET).elf
BIN = $(TARGET).bin

# Rules
all: $(BIN)

$(BIN): $(ELF)
	$(OBJCOPY) -O binary $< $@
	@echo "Built $(BIN)"

$(ELF): $(OBJS) linker.ld
	$(LD) $(LDFLAGS) $(OBJS) -o $@
	@echo "Linked $(ELF)"

start.o: start.S
	$(AS) $(ASFLAGS) $< -o $@

boot.o: boot.cpp uart.h
	$(CXX) $(CXXFLAGS) -c $< -o $@

uart.o: uart.cpp uart.h
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	rm -f $(OBJS) $(ELF) $(BIN)

# Run in QEMU
run: $(BIN)
	qemu-system-aarch64 -machine virt -cpu cortex-a53 -nographic \
		-kernel $(BIN) -serial mon:stdio

# Debug with GDB
debug: $(ELF)
	qemu-system-aarch64 -machine virt -cpu cortex-a53 -nographic \
		-kernel $(BIN) -serial mon:stdio -s -S &
	$(PREFIX)gdb $(ELF) -ex "target remote :1234"

.PHONY: all clean run debug